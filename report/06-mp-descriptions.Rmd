\newpage

`r if(knitr:::is_latex_output()) '\\Appendices'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-}'`

# DATA-LIMITED MANAGEMENT PROCEDURES {#app:MPs}

## SELECTION OF CANDIDATE MANAGEMENT PROCEDURES BASED ON DATA REQUIREMENTS

```{r screening-table, include=FALSE}
library(dplyr)
table_screening <- readr::read_csv(here::here("report/data/dlmtool-mps.csv")) %>%
  select(-Comment) %>%
  mutate(Candidate = ifelse(Candidate == "Y", "Yes", "No")) %>%
  mutate(`Reason for exclusion` =
      ifelse(is.na(`Reason for exclusion`), "", `Reason for exclusion`))

table_screening$`Management Procedure` <-
  sapply(table_screening$`Management Procedure`, function(x) {
  paste(paste0("\\texttt{", strsplit(x, " ")[[1]], "}"), collapse = " ")
})

table_screening$`Management Procedure` <- gsub("\\_", "\\\\_", table_screening$`Management Procedure`)

table_screening <- arrange(table_screening, desc(Candidate),
  `Reason for exclusion`, `Management Procedure`)

knitr::kable(table_screening,
  caption = "Management procedures, brief descriptions, and why they were or were not selected as candidates in our screening analysis.",
  booktabs = TRUE,
  longtable = TRUE,
  linesep = "\\addlinespace",
  escape = FALSE,
  format = "latex") %>%
  kableExtra::column_spec(column = 1, width = "4cm") %>%
  kableExtra::column_spec(column = 2, width = "5.5cm") %>%
  kableExtra::column_spec(column = 4, width = "3.5cm") %>%
  kableExtra::kable_styling(latex_options = "repeat_header",
    repeat_header_text = "", repeat_header_method = "replace") %>%
  sub("\\caption\\[\\]\\{\\}", "\\caption*{}", .)
```

## MANAGEMENT PROCEDURE DESCRIPTIONS

Here we include an overview of the output-controlled (TAC-based) MPs available in DLMtool that are relevant to this framework along with some additional variants and MPs used in recent assessments for other BC groundfish.

The notation between MPs is not always consistent (e.g., different symbols may be used for the slope of a relative abundance index), but we have aimed to maintain consistency with the DLMtool documentation or other publications where MPs were developed wherever possible.

<!-- TODO: or just make it consistent! slope, tuning parameters, C or TAC, index symbol...-->

```{r, results='asis', include=FALSE, eval=FALSE}
mps <- DLMtool::MPtype(DLMtool::avail('MP')) %>%
  dplyr::filter(Recs == "TAC") %>%
  dplyr::filter(!MP %in% grep("CC[2-9]+", .$MP, value = TRUE) )
csasdown::csas_table(mps)
```

### AvC: Average catch

The mean historical catch is calculated and used to set a constant TAC. The TAC in year $y$ is calculated as:

$$
\textrm{TAC}_y = \frac{\sum_{y=1}^{n}C_y}{n}
$$

where $n$ is the number of historical years, and $C_y$ is the catch in historical year $y$. 

For our purposes in British Columbia, we also suggest an alternate version of AvC, AvC_1997 that sets the TAC to the average catch since ITQ implementation in 1996:

$$
\textrm{TAC}_y = \frac{\sum_{y_{\textrm{ITQ}}=1}^{n}C_y}{n}
$$

where $y_{\textrm{ITQ}}$ represents the equivalent of 1997 for trawl fisheries in the historical period of the MSE. For specific stocks, analysts might consider other starting years that are relevant to that stock. We note that this MP is static and therefore does not incorporate feedback between subsequent stock status and MP recommendations. Nonetheless, it represents a simple MP that may prove to satisfy performance metrics depending on average historical catches.

<!-- TODO: write AvC_1997 -->

### CC: Constant catch

In this MP, TAC is calculated as some fraction of the average historical catch over the last 5 years [@geromont2015]:

$$
\textrm{TAC} = (1-x)C_{\textrm{ave}},
$$

where $x$ lies between 0 and 1, and $C_\textrm{ave}$ is average historical catch over the previous 5 years. The TAC is constant for all future projections. There are five variants of this procedure, which are the same besides the value of $x$:

- CC1: $x = 0$
- CC2: $x = 0.1$
- CC3: $x = 0.2$
- CC4: $x = 0.3$
- CC5: $x = 0.4$

### Iratio: Mean index ratio

This MP adjusts the TAC by a ratio, $\alpha$, with the numerator being the mean index in the most recent two years of the time series and the denominator being the mean index in the three years prior to those in the numerator. This MP is based on Method 3.2 used by ICES for Data-Limited Stocks [@ices2012; @jardim2015]. The TAC is calculated as:

$$
\textrm{TAC}_y = \alpha C_{y-1},
$$

where $C_{y-1}$ is the catch from the previous year and $\alpha$ is the ratio of the mean index in the most recent two years of the time series and the mean index in 3--5 years before current time. The number of reference years can be adjusted. The parameter $\alpha$ is defined as:

$$
\alpha = 
\left. \frac{I_{yr-1} + I_{yr-2}} {2} \middle/ 
\frac{I_{yr-3} + I_{yr-4} + I_{yr-5}} {3} \right. .
$$

Due to the biennial nature of the synoptic role surveys for any one area, we propose an alternative version of this MP, Iratio_6, which calculates the ratio with an additional year in the numerator so that there are always at least two years with data in the numerator.

$$
\alpha = 
\left. \frac{I_{yr-1} + I_{yr-2} + I_{yr-3}} {3} \middle/ 
\frac{I_{yr-4} + I_{yr-5} + I_{yr-6}} {3} \right. .
$$

and a version that uses 4 years in the numerator and denominator:

$$
\alpha = 
\left. \frac{I_{yr-1} + I_{yr-2} + I_{yr-3} + I_{yr-4}} {4} \middle/ 
\frac{I_{yr-5} + I_{yr-6} + I_{yr-7} + I_{yr-8}} {4} \right. .
$$

<!-- TODO: add this longer version of Iratio -->
<!-- TODO: make a consistent whether we use C_y-1 or TAC_y-1 -->

### GB_slope: Geromont and Butterworth index slope

This MP adjusts TAC based on previous catch and the trend in a relative abundance index to aim for relatively stable catch rates [@geromont2015] (Fig. \@ref(fig:mp-gbslope-demo)). The TAC is calculated as:

$$
\textrm{TAC}_y= C_{y-1}(1+\lambda I),
$$

where $C_{y-1}$ is catch from the previous year, $I$ is the slope of the linear regression of the log of an abundance index over the last $n$ years (default in DLMtool of $n = 5$), and $\lambda$ is a gain/smoothing parameter between 0 and 1 that controls how quickly TAC is adjusted based on the slope of the index. The TAC is subject to the following conditions that limit the rate at which the TAC can be adjusted up or down:

- if next TAC > 1.2 last catch, then TAC = 1.2 $\times$ last catch
- if next TAC < 0.8 last catch, then TAC = 0.8 $\times$ last catch.

The default $\lambda$ value is 1 in DLMtool. Here we propose adding versions with lower versions of $\lambda$ ($\lambda = 0.50$ and $\lambda = 0.66$), which are therefore slightly less responsive to changes in the relative abundance index. Furthermore, we propose extending the linear regression to encompass 6 or 8 years, due to the biennial nature of the synoptic trawl surveys, thereby encompassing a constant number of years with data. The gain parameter, and the number of years included in the slope calculation, could be explored as tuning parameters.

```{r mp-gbslope-demo, fig.cap="Illustration of GB\\_slope across different values of $\\lambda$, the gain/smoothing parameter that controls how sensitive the TAC recommendations are to changes in the relative abundance index.", fig.width=6, out.width="3.75in"}
f <- function(catch_previous = 100, lambda = 1, slope) {
  tac_star <- catch_previous * (1 + lambda * slope)
  tac <- tac_star
  if (tac_star / catch_previous > 1.2) tac <- catch_previous * 1.2
  if (tac_star / catch_previous < 0.8) tac <- catch_previous * 0.8
  tac
}
pars <- expand.grid(
  catch_previous = 100,
  lambda = c(0.50, 0.66, 1.00),
  slope = seq(-0.5, 0.5, length.out = 200)
)
pars$tac <- purrr::pmap_dbl(pars, f)

library(ggplot2)
library(dplyr)
pars %>%
  mutate(lambda = sprintf("%.2f", (lambda))) %>%
  ggplot(aes(slope, tac, color = lambda)) +
  geom_line() +
  ggsidekick::theme_sleek() +
  labs(
    colour = expression(gamma),
    x = "Slope in ln(index)",
    y = "TAC (based on 100 last year)"
  ) +
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  scale_color_brewer(palette ="Set2")
```

<!-- TODO: create a version with lambda set to smaller values and 6 or 8 years -->

### Islope: Index slope tracking

This management procedure incrementally adjusts the TAC in an attempt to maintain a constant relative abundance index (Fig. \@ref(fig:mp-islope-demo)). The MP is similar to GB_slope with the addition of a parameter that determines the TAC in the first projection year and different choices of the gain/smoothing parameter. The TAC is calculated as:

$$
\textrm{TAC}_y = \textrm{TAC}^*(1+\lambda I),
$$

where $\textrm{TAC}^*$ is $(1-xx)$ multiplied by the mean catch from the past 5 years for the first projection year. In subsequent years, $\textrm{TAC}^*$ is the TAC from the previous year. $\lambda$ is a gain parameter, and $I$ is the slope of the ln relative abundance index over the past $n$ years (default $n = 5$).

There are four variants of this procedure:

- Islope1: The least biologically precautionary, with $\lambda = 0.4$ and $xx = 0.2$
- Islope2: Increasingly biologically precautionary, with $\lambda = 0.4$ and $xx = 0.3$
- Islope3: Increasingly biologically precautionary, with  $\lambda = 0.4$ and $xx = 0.4$
- Islope4: The most biologically precautionary, with  $\lambda = 0.2$ and $xx = 0.2$

We have modified this MP to add a maximum proportional increase in TAC from one year to the next of 1.25.

```{r mp-islope-demo, fig.cap="Illustration of the Islope MPs across 2 values of $\\lambda$. The $xx$ parameter only affects the TAC in the initial projection year and is therefore not shown.", fig.width=6, out.width="3.75in"}
f <- function(catch_mean_recent = 100, xx = 0.2, lambda = 0.4,
  slope = 0.2) {
  tac_star <- (1 - xx) * catch_mean_recent
  tac <- tac_star * (1 + lambda * slope)
  if (tac < 0) tac <- 0
  if (tac / catch_mean_recent > 1.25) tac <- catch_mean_recent * 1.25
  tac
}
pars <- expand.grid(
  catch_mean_recent = 100,
  xx = c(0),
  lambda = c(0.2, 0.4),
  slope = seq(-0.75, 0.75, length.out = 200)
)
pars$tac <- purrr::pmap_dbl(pars, f)
pars %>%
  mutate(xx = paste("xx =", xx)) %>%
  ggplot(aes(slope, tac, color = as.factor(lambda))) +
  geom_line() +
  ggsidekick::theme_sleek() +
  labs(
    colour = expression(gamma),
    x = "Slope in ln(index)",
    y = "TAC (based on 100 last year)"
  ) +
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  scale_color_brewer(palette ="Set2") +
  scale_x_continuous(breaks = seq(-0.75, 0.75, 0.25))
```

### ICI: Index confidence interval

This MP adjusts the TAC based on the value of the relative abundance index in the current year divided by the relative abundance index mean and standard error  [@jardim2015] (Fig. \@ref(fig:mp-ici-demo)). The TAC is calculated as:

$$
\textrm{TAC}_y= \alpha C_{y-1},
$$

where $C_{y-1}$ is the catch from the previous year, and $\alpha$ is defined as:

$$
\alpha =
\begin{cases}
d, & \textrm{if}\ I \lt CI_L \\
u, & \textrm{if}\ I \gt CI_H \\
1, & \textrm{if}\ CI_L \le I \le CI_H.
\end{cases}
$$

The symbol $I$ represents the index in the most recent year, $d$ is 0.75 for both ICI and ICI2, $u$ is 1.05 and 1.25 for ICI and ICI2 (respectively), and $CI_L$ and $CI_H$ are the lower and upper bound of the confidence interval of mean historical index calculated in one of two ways. 

Written out more explicitly, the procedure for implementing these MPs is as follows:

- Calculate the mean ($\mu_I$) and standard deviation of the relative abundance index through time.
- Divide the standard deviation by the number of available relative abundance index time steps to derive the standard error ($\sigma_I$).

For ICI:

- Calculate $CI_L = \mu_I - 0.44 \sigma_I$ and $CI_H = \mu_I + 1.96 \sigma_I$.
- If $I \lt CI_L$, set $\alpha = 0.75$; if $I \gt CI_H$, set $\alpha = 1.05$.

For ICI2:

- Calculate $CI_L = \mu_I - 1.96 \sigma_I$ and $CI_H = \mu_I + 1.96 \sigma_I$.
- If $I \lt CI_L$, set $\alpha = 0.75$; if $I \gt CI_H$, set $\alpha = 1.25$.

Then, for both:

- If $I$ is between or equal to $CI_L$ and $CI_H$, maintain the same TAC as last year.

The values of 1.96 and 0.44 are derived from the normal distribution in which approximately 95% of the probability density is between $\pm 1.96 \sigma$ of the mean and approximately 35% of the probability density is between $\pm 0.44 \sigma$ of the mean. ICI2 is therefore less biologically precautionary than ICI: it lets the index value fall further from the mean before lowering the TAC and increases the TAC to a greater extent given an increase in the index value.

<!-- TODO: make sure this and others work if the last survey index value was NA -->
<!-- TODO: fix nI <- length(Index) to be number of non NAs in DLMtool -->

```{r mp-ici-demo, fig.cap="Illustration of the ICI and ICI2 MPs across different values of the current relative abundance index value compared to the long-term mean and various standard errors on that long-term mean."}
f_ici <- function(tac_prev, index_value, mu, sigma) {
  alpha <- 1
  ci_l <- mu - 0.44 * sigma
  ci_u <- mu + 1.96 * sigma
  if (index_value < ci_l) alpha <- 0.75
  if (index_value > ci_u) alpha <- 1.05
  tac_star <- tac_prev * alpha 
  if (tac_star < 0) tac_star <- 0
  tac_star
}
f_ici2 <- function(tac_prev, index_value, mu, sigma) {
  alpha <- 1
  ci_l <- mu - 1.96 * sigma
  ci_u <- mu + 1.96 * sigma
  if (index_value < ci_l) alpha <- 0.75
  if (index_value > ci_u) alpha <- 1.25
  tac_star <- tac_prev * alpha 
  if (tac_star < 0) tac_star <- 0
  tac_star
}
pars <- expand.grid(
  tac_prev = 100,
  mu = c(1),
  index_value = seq(0.3, 3, length.out = 200),
  sigma = c(0.1, 0.2, 0.5)
)
pars2 <- pars
pars$tac <- purrr::pmap_dbl(pars, f_ici)
pars2$tac <- purrr::pmap_dbl(pars2, f_ici2)
pars <- bind_rows(mutate(pars, type = "ICI"), mutate(pars2, type = "ICI2"))
pars$sigma <- as.factor(pars$sigma)
levels(pars$sigma) <- c(expression(sigma==0.1), expression(sigma==0.2), expression(sigma==0.5))

pars %>%
  ggplot(aes(index_value, tac)) +
  geom_line() +
  facet_grid(type~sigma, labeller = label_parsed) +
  ggsidekick::theme_sleek() +
  labs(
    x = "Ratio of current index value to longterm mean",
    y = "TAC (based on 100 last year)"
  ) +
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  geom_vline(xintercept = 1, lty = 2, alpha = 0.2) +
  scale_color_brewer(palette ="Set2")
```

### SBT1: "Simple" relative biomass target management procedure

SBT1 is an MP that makes incremental adjustments to TAC recommendations based on the trend in relative abundance index levels (Fig. \@ref(fig:mp-sbt1-demo)). The TAC is calculated as:

<!-- TODO: ref?  Rich Hillary at CSIRO?-->

<!-- $$ -->
<!-- \textrm{TAC}_y = -->
<!-- \begin{cases} -->
<!-- %C_{y-1} (1 - K_1 \left| \lambda \right| ^ \gamma ) & \textrm{if}\ \lambda < 0 \\ -->
<!-- C_{y-1} (1 + K_2 \left| \lambda \right| ) & \textrm{if}\ \lambda \ge 0, -->
<!-- \end{cases} -->
<!-- $$ -->

$$
\textrm{TAC}_y =
\begin{cases}
C_{y-1} (1 - K_1 \lvert \lambda \rvert ^\gamma) & \textrm{if}\ \lambda \lt 0 \\
C_{y-1} (1 + K_2 \lvert \lambda \rvert) & \textrm{if}\ \lambda \ge 0,
\end{cases}
$$

where $\lambda$ is the slope of the ln relative abundance index over the last $n$ years (default $n = 5$), and $K_1$, $K_2$, and $\gamma$ are arguments to the MP. By default of these parameters are $K_1 = 1.5$, $K_2 = 3$, and $\gamma = 1$. We propose including an alternative version with $\gamma = 0.66$ (decreases TAC more rapidly if the index is trending down) (Fig. \@ref(fig:mp-sbt1-demo)) and implementing an upper cap of 1.25 on the fraction that the TAC can be increased from one year to the next.

```{r mp-sbt1-demo, fig.cap="Illustration of SBT1."}
f <- function(c_y1, lambda, k1, k2, gamma) {
  if (lambda < 0) tac <- c_y1 * (1 - k1 * abs(lambda)^gamma)
  if (lambda >= 0) tac <- c_y1 * (1 + k2 * abs(lambda))
  if (tac < 0) tac <- 0
  if (tac / c_y1 > 1.25) tac <- c_y1 * 1.25
  tac
}
pars <- expand.grid(
  c_y1 = 100,
  lambda = seq(-0.5, 0.5, length.out = 200),
  k1 = c(1, 1.5, 3),
  k2 = c(1.5, 3, 5),
  gamma = c(0.66, 1, 1.5)
)
pars$tac <- purrr::pmap_dbl(pars, f)
pars %>%
  mutate(k1 = paste("K1 =", k1)) %>%
  mutate(k2 = paste("K2 =", k2)) %>%
  ggplot(aes(lambda, tac, colour = as.factor(gamma))) +
  geom_line() +
  facet_grid(k1 ~ k2) +
  ggsidekick::theme_sleek() +
  labs(
    colour = expression(gamma),
    x = expression(lambda ~ (Slope ~ "in" ~ ln(index))),
    y = "TAC (based on 100 last year)"
  ) +
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  scale_color_brewer(palette ="Set2")
# TODO: why does SBT1 do lm(I_hist ~ ind)) not in log space! Units!?
```

### IDX: Index-based MP from Cox et al. (In press)

This MP was used in the Cox et al. (In press) rebuilding plan for outside Yelloweye Rockfish in BC (Fig. \@ref(fig:mp-idx-demo)). The MP assigns TAC based on:

$$
\textrm{TAC}_y =
\begin{cases}
\textrm{TAC}_\textrm{Floor}, & \textrm{if}\ \Delta I_y \leq \delta_\textrm{min} \\
(1 + \Delta I_y ) \textrm{TAC}_{y-1}, & \textrm{if}\ \delta_\textrm{min} \lt \Delta I_y \leq \delta_\textrm{max} \\
(1 + \delta_\textrm{max}) \textrm{TAC}_{y-1}, & \textrm{if}\ \Delta I_y \gt \delta_\textrm{max},
\end{cases}
$$

where $\delta_\textrm{min}$ is the most negative drop allowed in the relative biomass index before the fishery is closed that year (by default assuming $\textrm{TAC}_\textrm{Floor} = 0$). We set $\delta_\textrm{min} = -0.50$ as in TODO, but this could be tuned for individual stocks. The maximum increase in TAC is capped at $\delta_\textrm{max} = 0.25$ by default.

This MP can be additionally smoothed:

$$
\textrm{TAC}_y = \lambda \cdot \textrm{TAC}_y + (1-\lambda) \cdot \textrm{TAC}_{y-1},
$$

where $\lambda$ controls the degree of smoothing and can range between 0 and 1. Cox et al. (In press) used $\lambda=0.5$. We define these MPs for DLMtool as IDX and ($\delta_{\textrm{min}} = 0.5$, $\delta_{\textrm{max}} = 0.25$, and $\textrm{TAC}_\textrm{Floor} = 0$) and IDXsmooth (same as IDX with $\lambda = 0.5$ to split the difference between the potentially proposed TAC and the one implemented the previous year).

```{r mp-idx-demo, fig.cap="Illustration of IDX."}
f <- function(tac_prev, tac_floor, delta_min, delta_max, delta_ind) {
  if (delta_ind <= delta_min) tac <- tac_floor
  if (delta_ind > delta_min && delta_ind <= delta_max)
    tac <- (1 + delta_ind) * tac_prev
  if (delta_ind > delta_max)
    tac <- (1 + delta_max) * tac_prev
  if (tac < 0) tac <- 0
  tac
}
pars <- expand.grid(
  tac_prev = 100,
  tac_floor = c(0, 10),
  delta_min = c(-0.5, -0.25),
  delta_max = c(0.2, 0.4),
  delta_ind = seq(-0.6, 0.6, length.out = 100)
)
pars$tac <- purrr::pmap_dbl(pars, f)
pars$delta_max <- as.factor(pars$delta_max)
pars$delta_min <- as.factor(pars$delta_min)
levels(pars$delta_min) <- c(expression(delta[min]==-0.50), expression(delta[min]==-0.25))
levels(pars$delta_max) <- c(expression(delta[max]==0.20), expression(delta[max]==0.40))
pars %>%
  ggplot(aes(delta_ind, tac, colour = as.factor(tac_floor))) +
  geom_line() +
  facet_grid(delta_min ~ delta_max, labeller = label_parsed) +
  ggsidekick::theme_sleek() +
  labs(
    colour = expression(TAC[Floor]),
    x = expression(Delta ~ I[y]),
    y = "TAC (based on 100 last year)"
  )+
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  scale_color_brewer(palette ="Set2")
```

### IT: Iterative index target

An index target MP where the TAC is modified according to current index levels, which is calculated as the mean index over the last 5 years, relative to a target level. Traditionally this target level is set to the index value at MSY subject to observation error. Since it will be challenging for us to apply this to real data in a manner consistent with the simulation, we instead propose modifying this MP to set the target index level to a historical index level likely chosen on a stock by stock basis. Provisionally, we set it to the mean index value from the 10 years prior to the projection period.

The TAC is calculated as:

$$
\textrm{TAC}_y = C_{y-1} I_\delta,
$$

where $C_{y-1}$ is the catch from the previous year and $I_\delta$ is the ratio of the mean index over the past 5 years to the reference index level.

There are two variants of this procedure:

- IT5 where the maximum annual changes to the TAC are 5%
- IT10 where the maximum annual changes to the TAC are 10%

<!-- *TODO: implement this historical reference version* -->

### Itarget: Incremental index target

A management procedure that incrementally adjusts the TAC from a reference level that is a fraction of mean recent catches to a target relative abundance index.

If $I_\textrm{recent}\ge I_0$ the TAC is calculated as:

$$
\textrm{TAC}_y = 0.5\ \textrm{TAC}^* \left[1+\left(\frac{I_\textrm{recent} - I_0}{I_\textrm{target} - I_0}\right)\right],
$$

otherwise:

$$
\textrm{TAC}_y = 0.5\ \textrm{TAC}^*\left(\frac{I_\textrm{recent}}{I_0}\right)^2,
$$

where $I_0$ is $0.8 I_\textrm{ave}$ (the average index over the 10 years prior to the projection period), $I_\textrm{recent}$ is the average index over the past 5 years, $I_\textrm{target}$ is $I_\textrm{multi} \cdot I_\textrm{ave}$, and $\textrm{TAC}^*$ is $(1-xx)C$ where $xx$ and $I_\textrm{multi}$ are arguments to the function and $C$ is the average catch over the last 5 years of the historical period.

There are four index/CPUE target MPs proposed by @geromont2015:

- Itarget1: The least biologically precautionary, with $xx = 0$ and $I_\textrm{multi} = 1.5$
- Itarget2: Increasingly biological precautionary, with $xx = 0$ and $I_\textrm{multi} = 2.0$
- Itarget3: Increasingly biological precautionary, with $xx = 0$ and $I_\textrm{multi} = 2.5$
- Itarget4: Most biological precautionary, with $xx = 0.3$ and $I_\textrm{multi} = 2.5$

```{r mp-itarget-demo, fig.cap="Illustration of the Itarget MP."}
f <- function(avg_catch_hist, Irecent, Iave, xx, Imulti, ...) {
  TACstar <- (1 - xx) * avg_catch_hist
  Itarget <- Iave * Imulti
  I0 <- 0.8 * Iave
  if (Irecent >= I0) {
    TAC <- 0.5 * TACstar * (1 + ((Irecent - I0)/(Itarget - I0)))
  } else {
    TAC <- 0.5 * TACstar * (Irecent/I0)^2
  }
  if (TAC < 0) tac <- 0
  TAC
}
pars1 <- expand.grid(
  avg_catch_hist = 100,
  Irecent = seq(0.1, 3, length.out = 300),
  Iave = c(1),
  xx = c(0.0),
  Imulti = c(1.5),
  type = "Itarget1", stringsAsFactors = FALSE
)
pars2 <- pars1
pars2$type <- "Itarget2"
pars2$Imulti <- 2

pars3 <- pars1
pars3$type <- "Itarget3"
pars3$Imulti <- 2.5

pars4 <- pars1
pars4$type <- "Itarget4"
pars4$Imulti <- 2.5
pars4$xx <- 0.3

pars <- bind_rows(list(pars1, pars2, pars3, pars4))
pars$tac <- purrr::pmap_dbl(pars, f)
pars %>%
  mutate(xx = paste("xx =", xx)) %>% 
  mutate(Imulti = paste("Imulti =", Imulti)) %>% 
  ggplot(aes(Irecent, tac, colour = type)) +
  geom_line() +
  ggsidekick::theme_sleek() +
  facet_grid(xx~Imulti) +
  labs(
    colour = "MP",
    x = expression(I[recent]/I[target]),
    y = "TAC (based on 100 average\nin last 5 historical years)"
  ) +
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  geom_vline(xintercept = 1, lty = 2, alpha = 0.2) +
  scale_color_brewer(palette ="Set2") +
  theme(legend.position = "top")
```

### ITM: Index target based on natural mortality rate

An index target MP where the TAC is modified according to current index levels. The current index level is calculated as the mean index over some number of years determined by natural mortality $M$ relative to a target level (Figs \@ref(fig:mp-itm-demo)).

$$
\textrm{TAC}_y = \textrm{TAC}_{y-1} \delta I,
$$

where $\delta I$ is the ratio of the mean index over $4 \left(1/M\right)^{1/4}$ years to the reference index. The maximum fractional change in TAC is determined by $mc$, defined as $mc = \textrm{max} \left( \left( 5+25M \right) / 100,\ 0.2\right)$. As in the other reference index MPs, instead of using the default relative index value at MSY as the reference, we use an historical period of the index, provisionally 2002--2012.

```{r mp-itm-demo, fig.cap="Illustration of the ITM MP. (a) Illustration of how TAC recommendation is based on natural mortality (M) and $\\delta I$, the proportional change in the recent relative abundance index compared to a reference level. Note that the effect of M only appears for large values of M---0.2 and 0.5 are overlapping in this figure. (b) Illustration of how M relates to the number of years over which to calculate the mean recent relative abundance index.", fig.asp=0.385}
f <- function(tac_prev, M, deltaI) {
 mc <- max(c((5 + 25 * M)/100), 0.2)
 if (deltaI < (1 - mc)) 
   deltaI <- 1 - mc
 if (deltaI > (1 + mc)) 
   deltaI <- 1 + mc
 tac <- tac_prev * deltaI
 if (tac < 0) tac <- 0
 tac
}
pars <- expand.grid(
  tac_prev = 100,
  M = c(0.2, 0.5, 0.8, 0.9),
  deltaI = c(0.5, 0.666, 1, 1.5, 2)
)
pars$tac <- purrr::pmap_dbl(pars, f)
fudge <- 0.2
pars$tac[pars$M == 0.2] <- pars$tac[pars$M == 0.2]
pars$tac[pars$M == 0.5] <- pars$tac[pars$M == 0.5] + fudge
pars$tac[pars$M == 0.8] <- pars$tac[pars$M == 0.8]
pars$tac[pars$M == 0.9] <- pars$tac[pars$M == 0.9]
g1 <- pars %>%
  ggplot(aes(deltaI, tac, colour = as.factor(M))) +
  geom_line() +
  ggsidekick::theme_sleek() +
  labs(
    colour = expression(M),
    x = expression(delta ~ I),
    y = "TAC (based on 100 last year)"
  )+
  geom_hline(yintercept = 100, lty = 2, alpha = 0.4) +
  scale_color_brewer(palette ="Set2") + 
  theme(legend.position = c(0.2, 0.75))

f <- function(M) {
 4 * (1/M)^(1/4)
}
pars <- expand.grid(
  M = seq(0.05, 0.8, length.out = 300)
)
pars$years <- purrr::pmap_dbl(pars, f)
g2 <- pars %>%
  ggplot(aes(M, years)) +
  geom_line() +
  ggsidekick::theme_sleek() +
  labs(
    x = expression(M),
    y = "Years"
  )
cowplot::plot_grid(g1, g2, labels = "auto")
```

<!-- TODO: look at trlnorm even for 1 rep here!  -->
<!-- TODO: implement the historical reference -->

## MODEL-BASED MANAGEMENT PROCEDURES

### SURPLUS PRODUCTION MODEL

In addition to the data-based MPs described above, we propose including a simple surplus production model paired with a harvest control rule as a model-based MP. Here, we use the surplus production model implemented in MSEtool (REF) and based on Fletcher (1978). Here we include a a modified version of the model description from the package vignette for completeness.

Biomass $B_t$ in year $t$ is calculated as

<!-- TODO: add Fletcher 1978 -->

$$
B_t = B_{t-1} + P_{t-1} - C_{t-1},
$$

where $C_t$ is the observed catch and $P_t$ is the surplus production given by

$$
P_t = \gamma \times \textrm{MSY} \times \left(\dfrac{B_t}{K}-\left[\dfrac{B_t}{K}\right]^n\right),
$$

where $K$ is the carrying capacity, $\textrm{MSY}$ is the estimated maximum sustainable yield, and $n$ is the parameter that controls shape of the production curve, and
$\gamma$ is

$$
\gamma = \dfrac{1}{n-1}n^{n/(n-1)}.
$$

We fix $n = 2$ to represent a symmetrical Schaefer (REF) production curve.

By conditioning the model on observed catch, the predicted index $\hat{I}_t$ is

$$
\hat{I}_t = \hat{q} \hat{B}_t
$$
and the harvest rate is

$$
\hat{F}_t = \dfrac{C_t}{\hat{B}_t}.
$$

The likelihood of the observed index $I_t$, assuming a lognormal distribution, is

$$
\log(I_t) \sim N(\log[\hat{I}_t], \sigma^2).
$$

<!-- TODO: finish up -->

We pair this surplus production model with the following harvest control rules (Fig. \@ref(fig:mp-hcrs)):

- HCR-MSY: Fish at the calculated MSY.

- HCR-4010: Above 40% of estimated $\textrm{SSB}/\textrm{SSB}_0$, fish at the calculated MSY; at 10% of estimated $\textrm{SSB}/\textrm{SSB}_0$, stop fishing; between 10% and 40%, interpolate the adjustment factor linearly. This is a commonly applied HCR in the fisheries literature.

- HCR-8040: Above 80% of estimated $\textrm{SSB}/\textrm{SSB}_0$, fish at the calculated MSY; at 40% of estimated $\textrm{SSB}/\textrm{SSB}_0$, stop fishing; between 40% and 80%, interpolate the adjustment factor linearly. This HCR follows the spirit of the provisional upper stock reference and limit reference points from DFO's Sustainable Fisheries Framework. We note, however, that an MP's HCR does not necessarily need to match these control points to be consistent with the provisional control points in the Single Fisheries Framework. For example, a model may generate biased estimates of $\textrm{SSB}/\textrm{SSB}_0$ and be better paired with a different HCR to obtain performance approximately in line with the provisional upper stock reference and limit reference points.

```{r, mp-hcrs, fig.cap="Proposed provisional harvest control rules to associate with model-based MPs.", fig.asp=0.35, fig.width=9, warning=FALSE}
f <- function (Brel, LRP, TRP, rel_min = 0, rel_max = 1, ...) {
    adj <- rep(rel_max, length(Brel))
    adj[Brel <= LRP] <- rel_min
    cond <- Brel > LRP & Brel < TRP
    adj[cond] <- (rel_max - rel_min)/(TRP - LRP) * (Brel[cond] - 
        LRP) + rel_min
    adj
}
pars8040 <- expand.grid(
  Brel = seq(0, 1, length.out = 200),
  LRP = c(0.4),
  TRP = c(0.8),
  type = "HCR-8040", stringsAsFactors = FALSE)
pars8040$tac <- purrr::pmap_dbl(pars8040, f)# + 0.0030

pars4010 <- expand.grid(
  Brel = seq(0, 1, length.out = 200),
  LRP = c(0.1),
  TRP = c(0.4),
  type = "HCR-4010", stringsAsFactors = FALSE)
pars4010$tac <- purrr::pmap_dbl(pars4010, f) #+ 0.0015

parsMSY <- expand.grid(
  Brel = seq(0, 1, length.out = 200),
  LRP = NA,
  TRP = NA,
  type = "HCR-MSY", stringsAsFactors = FALSE)
parsMSY$tac <- 1 

pars <- bind_rows(pars8040, pars4010) %>% 
  bind_rows(parsMSY)

pars$type <- as.factor(pars$type)
pars$type <- forcats::fct_relevel(pars$type, "HCR-MSY", "HCR-4010", "HCR-8040")
pars %>%
  ggplot(aes(Brel, tac)) +
  geom_line() +
  facet_wrap(~type) +
  ggsidekick::theme_sleek() +
  labs(
    x = expression(Estimated~SSB/SSB[0]),
    y = "TAC adjustment factor\n(proportion of MSY)"
  )+
  geom_vline(aes(xintercept = LRP), lty = 2, alpha = 0.4) +
  geom_vline(aes(xintercept = TRP), lty = 2, alpha = 0.4)
```



