\clearpage

```{r}
library(gfdlm)
science_name <- "Glyptocephalus zachirusadus"
drex <- gfdlm:::load_data_rex() %>% gfdlm:::filter_data_rex()
```

# REX SOLE OPERATING MODEL DEFINITION {#app:desc-om-rex}

```{r message = FALSE}
library(DLMtool)
knitr_results <- TRUE
knitr_echo <- TRUE
```

## STOCK SLOT DESCRIPTIONS {#app:desc-stock-rex}

```{r warnings = FALSE}
stock_rex <- methods::new('Stock')
```

```{r rex-stock-defaults, echo=FALSE}
stock_rex@Size_area_1 <- c(0.5, 0.5)
stock_rex@Frac_area_1 <- c(0.5, 0.5)
stock_rex@Prob_staying <- c(0.5, 0.5)
stock_rex@Mexp <- c(NA_real_, NA_real_)
```

<!-- slot-chunk-begin -->
### Name {#app:desc-stock-name-rex}

*The name of the Stock object. Single value. Character string*


```{r desc-stock-name-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Name <- "Rex Sole"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Common_Name {#app:desc-stock-common_name-rex}

*Common name of the species. Character string*


```{r desc-stock-common_name-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Common_Name <- "Rex Sole"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Species {#app:desc-stock-species-rex}

*Scientific name of the species. Genus and species name. Character string*


```{r desc-stock-species-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Species <- "Glyptocephalus zachirus"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### maxage {#app:desc-stock-maxage-rex}

*The maximum age of individuals that is simulated (there is no plus group ). Single value. Positive integer*

<!-- From @turnock2005. This is the plus group value. TODO Can't find turnock2005 -->

From @munk2001, who document the maximum ages observed in various surveys in Alaska, note the maximum age observe for Rex Sole in the Gulf of Alaska is 27 years. We don't have ages in our database to inform the maximum age for this region. @mcgilliard2017 used age 20 as the plus group age in their model, since we don't have a plus group, maybe safer to use 27. We should test sensitivity to this. If important this would add to the VOI study.

```{r desc-stock-maxage-rex, results = knitr_results, echo = knitr_echo}
stock_rex@maxage <- 27
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### R0 {#app:desc-stock-r0-rex}

*The magnitude of unfished recruitment. Single value. Positive real number*

The absolute value is meaningless here. Arbitrarily pick a value.

```{r desc-stock-r0-rex, results = knitr_results, echo = knitr_echo}
stock_rex@R0 <- 1000
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### M {#app:desc-stock-m-rex}

*Natural mortality rate. Uniform distribution lower and upper bounds. Positive real number*

@mcgilliard2017 used 0.17 for M but they also note that growth rates and size can vary with latitude, which can affect M. Here add a little uncertainty. 

```{r desc-stock-m-rex, results = knitr_results, echo = knitr_echo}
stock_rex@M <- c(0.17, 0.2) 
```
<!-- slot-chunk-end -->


<!-- slot-chunk-begin -->
### h {#app:desc-stock-h-rex}

*Steepness of the stock recruit relationship. Uniform distribution lower and upper bounds. Values from 1/5 to 1*

@maunder2012 cite @myers1999 who found a median value of steepness of 0.80 for flatfish and note that, because of the bias in the value estimated for North Atlantic Cod in that paper, the value might be closer to 0.94. @grandin2017arrowtooth estimated steepness for Arrowtooth Flounder, but found their posterior was highly influenced by their prior (they estimated a median of 0.88 with a 95% CI of 0.69--0.98). Here we will choose a value that approximately encompasses this range.

```{r desc-stock-h-rex, results = knitr_results, echo = knitr_echo}
stock_rex@h <- c(0.70, 0.95)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### SRrel {#app:desc-stock-srrel-rex}

*Type of stock-recruit relationship. Single value, switch (1) Beverton-Holt (2) Ricker. Integer*

We will use a Beverton-Holt stock-recruit relationship as is been used in most British Columbia groundfish assessments and is assumed in the estimates of steepness defined in this operating model.

```{r desc-stock-srrel-rex, results = knitr_results, echo = knitr_echo}
stock_rex@SRrel <- 1L
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Perr {#app:desc-stock-perr-rex}

*Process error, the CV of lognormal recruitment deviations. Uniform distribution lower and upper bounds. Non-negative real numbers*

@thorson2014 finds the mean standard deviation of log recruitment deviations for Pleuronectiformes to be about 0.64 with a standard deviation of about 0.26. We will set our uniform distribution to be approximately plus or minus one standard deviation. @mcgilliard2017 used 0.6 for Gulf of Alaska stocks.

```{r desc-stock-perr-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Perr <- c(0.4, 0.9)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### AC {#app:desc-stock-ac-rex}

*Autocorrelation in recruitment deviations rec(t)=AC*rec(t-1)+(1-AC)*sigma(t). Uniform distribution lower and upper bounds. Non-negative real numbers*

@thorson2014 finds the mean autocorrelation for Pleuronectiformes to be about 0.44 with a standard deviation of about 0.27. We will set our uniform distribution to be approximately plus or minus one standard deviation.

```{r desc-stock-ac-rex, results = knitr_results, echo = knitr_echo}
stock_rex@AC <- c(0.2, 0.7)
```
<!-- slot-chunk-end -->



<!-- slot-chunk-begin -->
### Linf {#app:desc-stock-linf-rex}

*Maximum length. Uniform distribution lower and upper bounds. Positive real numbers*

We don't have ages in our database to fit a von Bertalanffy model, but we can look at the distribution of lengths from our survey samples. This is the distribution across all fish sampled across these surveys.

```{r rex-length1, echo=FALSE}
rex_lengths <- dplyr::filter(drex$survey_samples, !is.na(length))
hist(rex_lengths$length)
```

The data are coming from the following surveys:

```{r rex-length2}
table(rex_lengths$survey_series_desc)
```

We can look at the 95%, 99%, and 100% quantiles for males and then for females:

```{r rex-length3}
dplyr::filter(rex_lengths, sex == 1) %>%
  pull(length) %>%
  quantile(probs = c(0.95, 0.99, 1.00))
dplyr::filter(rex_lengths, sex == 2) %>%
  pull(length) %>%
  quantile(probs = c(0.95, 0.99, 1.00))
```

However, $L_\mathrm{inf}$ represents the average maximum length, not the maximum observed length.

@turnock2005 (Table 4.12) found the $L_\mathrm{inf}$ for males was 39.5 cm and $L_\mathrm{inf}$ for females was 44.9 cm in the Gulf of Alaska. This looks roughly in line with the length samples in our database. We will use these values to be consistent with their other growth parameters.

```{r desc-stock-linf-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Linf <- c(39.5, 44.9)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### K {#app:desc-stock-k-rex}

*von Bertalanffy growth parameter k. Uniform distribution lower and upper bounds. Positive real numbers*

@turnock2005 (Table 4.12) in the Gulf of Alaska estimated $k$ to be 0.38 and 0.31 for males and females, respectively. We will use these values.

```{r desc-stock-k-rex, results = knitr_results, echo = knitr_echo}
stock_rex@K <- c(0.31, 0.38)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### t0 {#app:desc-stock-t0-rex}

*von Bertalanffy theoretical age at length zero. Uniform distribution lower and upper bounds. Non-positive real numbers*

@turnock2005 (Table 4.12) in the Gulf of Alaska estimated $t_0$ to be 0.79 and 0.69 for males and females, respectively. We assume these should be negative.

```{r desc-stock-t0-rex, results = knitr_results, echo = knitr_echo}
stock_rex@t0 <- c(-0.79, -0.69)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LenCV {#app:desc-stock-lencv-rex}

*Coefficient of variation of length-at-age (assumed constant for all age classes). Uniform distribution lower and upper bounds. Positive real numbers*

Given uncertainty in the growth parameters as applied in BC, set a fairly large CV (0.25).

```{r desc-stock-lencv-rex, results = knitr_results, echo = knitr_echo}
stock_rex@LenCV <- c(0.25, 0.25)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### L50 {#app:desc-stock-l50-rex}

*Length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers*

We have sufficient maturity and length data to fit a logistic maturity model. @mcgilliard2017 noted that length at maturity varied by latitude, but that age at maturity was fairly consistent among stocks.

```{r desc-stock-l50-rex, results = knitr_results, echo = knitr_echo}
m_mat <- gfplot::fit_mat_ogive(drex$survey_samples, type = "length")
mat_perc <- gfdlm:::extract_maturity_perc(coef(m_mat$model))
se_l50 <- gfdlm:::delta_method(~ -(log((1/0.5) - 1) + x1 + x3) / (x2 + x4),
    mean = coef(m_mat$model), cov = vcov(m_mat$model))
gfplot::plot_mat_ogive(m_mat)

stock_rex@L50 <- round(c(-2, 2) * se_l50 + mat_perc$f.p0.5, 1)
stock_rex@L50
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### L50_95 {#app:desc-stock-l50_95-rex}

*Length increment from 50 percent to 95 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers*

We can calculate this as a derived parameter from our logistic maturity model:

```{r desc-stock-l50_95-rex, results = knitr_results, echo = knitr_echo}
se_l50_95m <- gfdlm:::delta_method(
  ~ -(log((1/0.95) - 1) + x1 + x3) / (x2 + x4) -
    -(log((1/0.5) - 1) + x1 + x3) / (x2 + x4),
    mean = coef(m_mat$model), cov = vcov(m_mat$model))
stock_rex@L50_95 <- round(c(-2, 2) * se_l50_95m + (mat_perc$f.p0.95 - mat_perc$f.p0.5), 1)
stock_rex@L50_95
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### D {#app:desc-stock-d-rex}

*Current level of stock depletion SSB(current)/SSB(unfished). Uniform distribution lower and upper bounds. Fraction*

This will be populated via the SRA model and so we will leave it blank here.

```{r desc-stock-d-rex, results = knitr_results, echo = knitr_echo}
stock_rex@D
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### a {#app:desc-stock-a-rex}

*Length-weight parameter alpha. Single value. Positive real number*

We have sufficient length and weight data to fit a model to our data for both sexes combined:


```{r desc-stock-a-rex, results = knitr_results, echo = knitr_echo}
mlw <- gfplot::fit_length_weight(drex$survey_samples, sex = "all")
gfplot::plot_length_weight(object_all = mlw, col = c("All" = "black"))
stock_rex@a <- exp(mlw$pars[["log_a"]])
round(log(stock_rex@a), 2)
round(stock_rex@a,2)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### b {#app:desc-stock-b-rex}

*Length-weight parameter beta. Single value. Positive real number*

<!-- Alternatively from @mcgilliard2017: -->
<!-- - Female = 3.44963 -->
<!-- - Male = 3.30571 -->

```{r desc-stock-b-rex, results = knitr_results, echo = knitr_echo}
stock_rex@b <- mlw$pars[["b"]]
round(stock_rex@b, 2)
```
<!-- slot-chunk-end -->

How do these values compare to @mcgilliard2017:

Female a = 1.35e-06 

Male a  = 2.18e-06 

Female b = 3.45 

Male b  = 3.31 

A bit different. Should check sensitivity to these values.

<!-- slot-chunk-begin -->
### Fdisc {#app:desc-stock-fdisc-rex}

*Fraction of discarded fish that die. Uniform distribution lower and upper bounds. Non-negative real numbers*

Assume that all discarded fish die.

```{r desc-stock-fdisc-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Fdisc <- c(1,1)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Source {#app:desc-stock-source-rex}

*A reference to a website or article from which parameters were taken to define the stock object. Single value. Character string.*


```{r desc-stock-source-rex, results = knitr_results, echo = knitr_echo}
stock_rex@Source <- ""
```
<!-- slot-chunk-end -->


## FLEET SLOT DESCRIPTIONS {#app:desc-fleet-rex}

```{r warnings = FALSE}
fleet_rex <- DLMtool::Generic_Fleet
```

```{r warnings = FALSE, echo=FALSE}
fleet_rex@Esd <- c(0, 0)
fleet_rex@qinc <- c(0, 0)
fleet_rex@qcv <- c(0, 0)
fleet_rex@EffYears <- 1996:2018
fleet_rex@EffLower <- rep(1, length(fleet_rex@EffYears))
fleet_rex@EffUpper <- rep(1, length(fleet_rex@EffYears))
fleet_rex@Spat_targ <- c(1, 1)
```

<!-- slot-chunk-begin -->
### Name {#app:desc-fleet-name-rex}

*Name of the Fleet object. Single value. Character string.*


```{r desc-fleet-name-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@Name <- "BC Fleet"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### nyears {#app:desc-fleet-nyears-rex}

*The number of years for the historical spool-up simulation. Single value. Positive integer*

We will set the historical run-up to be approximately the length of the recorded commercial fishery.

```{r desc-fleet-nyears-rex, results = knitr_results, echo = knitr_echo}
catch_yrs <- unique(drex$catch$year)
c(catch_yrs[1], catch_yrs[length(catch_yrs)])
fleet_rex@nyears <- length(catch_yrs)
fleet_rex@nyears
```
<!-- slot-chunk-end -->


<!-- slot-chunk-begin -->
### L5 {#app:desc-fleet-l5-rex}

*Shortest length corresponding to 5 percent vulnerability. Uniform distribution lower and upper bounds. Positive real numbers*

There are very few commercial length samples to inform this parameter for our commercial WCVI samples:

```{r min-caught-rex1}
drex$commercial_samples %>%
  dplyr::filter(!is.na(length)) %>%
  nrow()
hist(drex$commercial_samples$length)
```

However, we can look at the commercial samples from our entire coast to inform this parameter:

```{r min-caught-rex2, message=FALSE}
fi <- here::here("generated-data/rex-coastwide-commercial-samples.rds")
if (!file.exists(fi)) {
  rex_commercial <- gfdata::get_commercial_samples("rex sole", unsorted_only = FALSE)
  saveRDS(rex_commercial, file = fi)
} else {
  rex_commercial <- readRDS(fi)
}
quantile(rex_commercial$length,
  probs = c(0.000, 0.005, 0.01, 0.025, 0.050, 0.500), na.rm = TRUE)
hist(rex_commercial$length)
```

We can look at the number of fish sample below various thresholds for length:

```{r min-caught-rex3}
dplyr::filter(rex_commercial, length <= 14) %>% nrow()
dplyr::filter(rex_commercial, length <= 15) %>% nrow()
dplyr::filter(rex_commercial, length <= 16) %>% nrow()
dplyr::filter(rex_commercial, length <= 17) %>% nrow()
```

Let's pick a range based on those values:

```{r min-caught-rex4}
l5 <- c(16, 18)
```

Based on the slot `isRel` below, this slot needs to be converted into a proportion of size at maturity. The 95% CI of size at maturity from this analysis is `r stock_rex@L50[[1]]` to `r stock_rex@L50[[2]]`.

```{r desc-fleet-l5-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@L5 <- c(l5[1]/stock_rex@L50[[2]], l5[2]/stock_rex@L50[[1]])
fleet_rex@L5
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LFS {#app:desc-fleet-lfs-rex}

*Shortest length that is fully vulnerable to fishing. Uniform distribution lower and upper bounds. Positive real numbers*

Here's a comparison of the commercial (from the entire coast) and survey samples (from WCVI):

```{r}
hist(rex_commercial$length, xlim = c(5, 60), breaks = 50)
par(new = TRUE)
plot(density(na.omit(drex$survey_samples$length)),
  xlim = c(5, 60), main = "", ylab = "", xlab = "", axes = FALSE)
abline(v = stock_rex@L50[[1]], col = "red")
abline(v = stock_rex@L50[[2]], col = "red")
```

Based on the slot `isRel` below, this slot needs to be converted into a proportion of size at maturity. Size at maturity has been entered as `r stock_rex@L50[[1]]` to `r stock_rex@L50[[2]]` (shown as vertical red lines in the above plot).

TODO: We will assume that Rex Sole is fully vulnerable to fishing by approximately size at maturity:

```{r desc-fleet-lfs-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@LFS <- c(0.8, 1.2)
```

<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Vmaxlen {#app:desc-fleet-vmaxlen-rex}

*The vulnerability of fish at `Stock@Linf` . Uniform distribution lower and upper bounds. Fraction*

We will set this to 1. Setting this to a value lower than 1 would be assuming dome-shaped selectivity.

```{r desc-fleet-vmaxlen-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@Vmaxlen <- c(1, 1)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### isRel {#app:desc-fleet-isrel-rex}

*Selectivity parameters in units of size-of-maturity (or absolute eg cm). Single value. Boolean.*

As mentioned above, the slots have been entered as units of size at maturity.

```{r desc-fleet-isrel-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@isRel <- TRUE
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LR5 {#app:desc-fleet-lr5-rex}

*Shortest length corresponding to 5 percent retention. Uniform distribution lower and upper bounds. Non-negative real numbers*

Let's assume it is quarter of Linf for now. Ask industry.

```{r desc-fleet-lr5-rex, results = knitr_results, echo = knitr_echo}
quarter_linf <- stock_rex@Linf/4
fleet_rex@LR5 <- c(quarter_linf,quarter_linf)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LFR {#app:desc-fleet-lfr-rex}

*Shortest length that is fully retained. Uniform distribution lower and upper bounds. Non-negative real numbers*

Let's assume it is half of Linf for now. Ask industry.

```{r desc-fleet-lfr-rex, results = knitr_results, echo = knitr_echo}

half_linf    <- stock_rex@Linf/2
fleet_rex@LFR <- c(half_linf, half_linf)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Rmaxlen {#app:desc-fleet-rmaxlen-rex}

*The retention of fish at `Stock@Linf` . Uniform distribution lower and upper bounds. Non-negative real numbers*

We don't have any length data on discards but assume that they will be retained if they are big.

```{r desc-fleet-rmaxlen-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@Rmaxlen <- c(1, 1)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### DR {#app:desc-fleet-dr-rex}

*Discard rate - the fraction of caught fish that are discarded. Uniform distribution lower and upper bounds. Fraction*

We looked at the discard rate since observers on the trawl fleet (1996). We set the bounds as mean +/ 1 SD as observed in the data:

```{r desc-fleet-dr-rex, results = knitr_results, echo = knitr_echo}
discards2 <- drex$catch %>%
  gfplot::tidy_catch() %>%
  dplyr::filter(gear == "Discarded") %>%
  rename(Discards = value) %>%
  select(-gear)

catch2 <- drex$catch %>%
  gfplot::tidy_catch() %>%
  dplyr::filter(gear == "Bottom trawl") %>%
  rename(Landed = value) %>%
  select(-gear)

discard_rate2 <- left_join(discards2, catch2) %>%
  mutate(frac_disc = Discards / (Landed + Discards))

mean_frac_d2 <- mean(discard_rate2$frac_disc)
sd_frac_d2 <- sd(discard_rate2$frac_disc)

frac_low2 <- mean_frac_d2 - sd_frac_d2
frac_high2 <- mean_frac_d2 + sd_frac_d2
fleet_rex@DR <- c(frac_low2, frac_high2)
fleet_rex@DR
```

<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### CurrentYr {#app:desc-fleet-currentyr-rex}

*The current calendar year (final year) of the historical simulations (eg 2011). Single value. Positive integer.*


```{r desc-fleet-currentyr-rex, results = knitr_results, echo = knitr_echo}
fleet_rex@CurrentYr <- 2018
```
<!-- slot-chunk-end -->



## OBS SLOT DESCRIPTIONS {#app:desc-obs-rex}

```{r warnings = FALSE}
obs_rex <- DLMtool::Generic_Obs
```


<!-- slot-chunk-begin -->
### Name {#app:desc-obs-name-rex}

*The name of the observation model object. Single value. Character string.*


```{r desc-obs-name-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Name <- "BC observation model"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Cobs {#app:desc-obs-cobs-rex}

Since 1996, observation error on catch should be very small:

<!-- TODO: does this affect historical build up because there was certainly much larger observation error on catch before 1996. -->
<!-- RF: No I think the historical catch uncertainty is dealt with in the historical MSE -->

```{r desc-obs-cobs-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Cobs <- c(0, 0.05)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Cbiascv {#app:desc-obs-cbiascv-rex}

*Log-normal coefficient of variation controlling the sampling of bias in catch observations for each simulation. Uniform distribution lower and upper bounds. Non-negative real numbers*

We will keep the at 0 because observation error on catch should be very small with 100% on board and dockside monitoring.

<!-- FIXME: what about the historical period? -->

```{r desc-obs-cbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Cbiascv <- c(0, 0)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### CAA_nsamp {#app:desc-obs-caa_nsamp-rex}

*Number of catch-at-age observation per time step. Uniform distribution lower and upper bounds. Positive real numbers*

This slot will not be relevant in the main operating model since none of the MPs make use of age data.

```{r desc-obs-caa_nsamp-rex, results = knitr_results, echo = knitr_echo}
obs_rex@CAA_nsamp
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### CAA_ESS {#app:desc-obs-caa_ess-rex}

*Effective sample size (independent age draws) of the multinomial catch-at-age observation error model. Uniform distribution lower and upper bounds. Positive integers*

This slot will not be relevant in the main operating model since none of the MPs make use of age data.

```{r desc-obs-caa_ess-rex, results = knitr_results, echo = knitr_echo}
obs_rex@CAA_ESS
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### CAL_nsamp {#app:desc-obs-cal_nsamp-rex}

*Number of catch-at-length observation per time step. Uniform distribution lower and upper bounds. Positive integers*

The number of Rex Sole fish sampled for length each year in the SYN WCVI survey is somewhere between 3000 and 4000; however, this is only done every second year. We will therefore divide this sample number by two.

```{r desc-obs-cal_nsamp-rex, results = knitr_results, echo = knitr_echo}
obs_rex@CAL_nsamp <- c(3000, 4000)/2
obs_rex@CAL_nsamp
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### CAL_ESS {#app:desc-obs-cal_ess-rex}

*Effective sample size (independent length draws) of the multinomial catch-at-length observation error model. Uniform distribution lower and upper bounds. Positive integers*

Based on the calculations described in @pennington2002 (TODO: explain elsewhere), the effective sample size for catch at length appears to be about 0.4 of the actual samples.

```{r desc-obs-cal_ess-rex, results = knitr_results, echo = knitr_echo}
obs_rex@CAL_ESS <- obs_rex@CAL_nsamp * 0.4
obs_rex@CAL_ESS
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Iobs {#app:desc-obs-iobs-rex}

*Observation error in the relative abundance indices expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Positive real numbers*

We will set this to the range of observed CV in the SYN WCVI survey:

```{r}
rex_cv_range <- dplyr::filter(drex$survey_index, survey_abbrev == "SYN WCVI") %>%
  dplyr::pull(re) %>%
  range() %>%
  round(2)
```

```{r desc-obs-iobs-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Iobs <- rex_cv_range
obs_rex@Iobs
```
<!-- slot-chunk-end -->


<!-- slot-chunk-begin -->
### Btobs {#app:desc-obs-btobs-rex}

*Log-normal coefficient of variation controlling error in observations of current stock biomass among years. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-btobs-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Btobs
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Btbiascv {#app:desc-obs-btbiascv-rex}

*Uniform-log bounds for sampling persistent bias in current stock biomass. Uniform-log distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-btbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Btbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### beta {#app:desc-obs-beta-rex}

*A parameter controlling hyperstability/hyperdepletion where values below 1 lead to hyperstability (an index that decreases slower than true abundance) and values above 1 lead to hyperdepletion (an index that decreases more rapidly than true abundance). Uniform distribution lower and upper bounds. Positive real numbers*

Set this to c(0,0) unless we are specifically interested in hyperstability/hyper depletion.

```{r desc-obs-beta-rex, results = knitr_results, echo = knitr_echo}
obs_rex@beta <- c(0,0)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LenMbiascv {#app:desc-obs-lenmbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers*

```{r desc-obs-lenmbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@LenMbiascv <- c(0,0)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Mbiascv {#app:desc-obs-mbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in observed natural mortality rate. Uniform distribution lower and upper bounds. Positive real numbers*

We don't have good data to go on for natural mortality rate so let's allow for a fairly large range in persistent bias. As a reminder, we set M to be drawn from a uniform distribution between `r stock_rex@M[[1]]` and `r stock_rex@M[[2]]`. 

Most MPs don't need an estimate of M, although the delay-difference (DD) MP does and may be sensitive to this value. The default value is 0.2 and may cause the DD MP to perform too well.



```{r desc-obs-mbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Mbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Kbiascv {#app:desc-obs-kbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in observed growth parameter K. Uniform distribution lower and upper bounds. Positive real numbers*

Since there is no ageing data for Rex Sole we are using parameters from other stocks (Gulf of Alaska). For stocks like this, we can expect some bias in von Bertalanffy growth parameters. Default is 0.1 for K and t0. this is probably okay but allow it to go up to 0.2. Default is 0.05 for Linf. Set this to 0.1.

```{r desc-obs-kbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Kbiascv <- c(0.1,0.2)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### t0biascv {#app:desc-obs-t0biascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in observed t0. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-t0biascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@t0biascv <- c(0.1,0.2)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Linfbiascv {#app:desc-obs-linfbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in observed maximum length. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-linfbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Linfbiascv <- c(0.1,0.2)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LFCbiascv {#app:desc-obs-lfcbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in observed length at first capture. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-lfcbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@LFCbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### LFSbiascv {#app:desc-obs-lfsbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in length-at-full selection. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-lfsbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@LFSbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### FMSYbiascv {#app:desc-obs-fmsybiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in FMSY. Uniform distribution lower and upper bounds. Positive real numbers*

Most MPs we are using don't require these inputs. Use the default values of 0.2.


```{r desc-obs-fmsybiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@FMSYbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### FMSY_Mbiascv {#app:desc-obs-fmsy_mbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in FMSY/M. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-fmsy_mbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@FMSY_Mbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### BMSY_B0biascv {#app:desc-obs-bmsy_b0biascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in BMSY relative to unfished. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-bmsy_b0biascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@BMSY_B0biascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Irefbiascv {#app:desc-obs-irefbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in relative abundance index at BMSY. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-irefbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Irefbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Brefbiascv {#app:desc-obs-brefbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in BMSY. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-brefbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Brefbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Crefbiascv {#app:desc-obs-crefbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in MSY. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-crefbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Crefbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Dbiascv {#app:desc-obs-dbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in stock depletion. Uniform distribution lower and upper bounds. Positive real numbers*

We are not using MPs that require an estimate of depletion. Use the default values here.


```{r desc-obs-dbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Dbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Dobs {#app:desc-obs-dobs-rex}

*Log-normal coefficient of variation controlling error in observations of stock depletion among years. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-dobs-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Dobs
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### hbiascv {#app:desc-obs-hbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in steepness. Uniform distribution lower and upper bounds. Positive real numbers*


```{r desc-obs-hbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@hbiascv
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### Recbiascv {#app:desc-obs-recbiascv-rex}

*Log-normal coefficient of variation for sampling persistent bias in recent recruitment strength. Uniform distribution lower and upper bounds. Positive real numbers*

Not sure where this is used. Leave at default value of c(0.1,0.3)


```{r desc-obs-recbiascv-rex, results = knitr_results, echo = knitr_echo}
obs_rex@Recbiascv
```
<!-- slot-chunk-end -->


## IMP SLOT DESCRIPTIONS {#app:desc-imp-rex}

```{r warnings = FALSE}
imp_rex <- DLMtool::Perfect_Imp
```


<!-- slot-chunk-begin -->
### Name {#app:desc-imp-name-rex}

*The name of the Implementation error object. Single value. Character string.*


```{r desc-imp-name-rex, results = knitr_results, echo = knitr_echo}
imp_rex@Name <- "BC Implementation"
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### TACFrac {#app:desc-imp-tacfrac-rex}

*Mean fraction of TAC taken. Uniform distribution lower and upper bounds. Positive real number.*

We need to discuss carry-over with industry. For many species they only take 70% and carry over 30% into next year.

For now set between 0.7 and 0.9.


```{r desc-imp-tacfrac-rex, results = knitr_results, echo = knitr_echo}
imp_rex@TACFrac <- c(0.7, 0.9)
```
<!-- slot-chunk-end -->

<!-- slot-chunk-begin -->
### TACSD {#app:desc-imp-tacsd-rex}

*Log-normal coefficient of variation in the fraction of Total Allowable Catch (TAC) taken. Uniform distribution lower and upper bounds. Non-negative real numbers.*

Assume that if TACFrac is not c(1,1), as it is in Perfect_Imp, then the SD should be set to something non-zero.

```{r desc-imp-tacsd-rex, results = knitr_results, echo = knitr_echo}
imp_rex@TACSD <- c(0.05, 0.05)
```
<!-- slot-chunk-end -->


<!-- ### Output the OM -->

<!-- *Output the Operating model.* -->

```{r output-rex}
rex_om <- new('OM', stock_rex, fleet_rex, obs_rex, imp_rex)
saveRDS(rex_om, file = here::here("generated-data", "rex-om.rds"))
```
